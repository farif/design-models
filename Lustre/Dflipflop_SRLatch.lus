-- Data/Delay flip-flop 
-- Design reference: https://www.electronicshub.org/d-flip-flop/
node D_flipflop(D, clk: bool) 
returns (Q0,Q1: bool);
var posedge: bool;
let
  posedge = RisingEdge(clk);
  (Q0,Q1) = SR_Latch(not D and posedge, D and posedge);
  -- After the start the flip-flop outputs remain complement to each other.
  check Step(D) > 0  => Q0 <> Q1 ; 
  --%MAIN;
tel

-- D Latch Lustre Model
node D_Latch(D, EN: bool) 
returns (Q0,Q1: bool);
let
  (Q0,Q1) = SR_Latch(not D and EN, D and EN);
tel

-- SR Latch Lustre Model
node SR_Latch(S, R: bool) 
returns (Q0,Q1: bool);
let
  Q0 = false -> NOR (R, pre Q1);
  Q1 = false -> NOR (S, pre Q0);
tel

-- Boolean NOR operand
node NOR(P, Q: bool) 
returns (Z: bool);
let
  Z = not (P or Q) ;
tel

-- Detect Rising Edge
node RisingEdge(clk: bool) returns (o: bool);
let
    o = false -> clk and not (pre clk);
tel

-- State counter
node Step (p: bool) 
returns (r: int);
let   
    r = 0 -> (pre r + 1);
tel