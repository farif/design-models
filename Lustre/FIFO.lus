--  FIFO Interface:
--                    __________
--                   \          \
--        data_in -->\          \--> data_out
--    write_event -->\   FIFO   \<-- read_event
--         Q_FULL <--\          \--> Q_EMPTY
--                   \__________\
-------------------------------------------------

type packet = int;
const MAX:int = 8;

-- Implementation of a Buggy Queue.
node FIFO(data_in :packet; write_event, read_event :bool) returns (data_out :packet; Q_EMPTY, Q_FULL :bool);
var memory :packet^MAX;
var c :int;
let
    c = 0 -> if (read_event and write_event) then pre c   
             else if(not Q_FULL and write_event) then (pre c + 1) 
             else if(not Q_EMPTY and read_event) then (pre c - 1)
             else pre c;
             
   Q_FULL = false -> if (pre c = 7) then true else pre Q_FULL;
   Q_EMPTY = true -> if (pre c >= 0) then false else pre Q_EMPTY;
   
   memory[c] = -1 -> if write_event and c < 8 then data_in else pre memory[c];
  -- data_out = -1 -> if read_event then pre memory[1] else -1 ;

tel

node FIFO_Specs(data_in :int; write_event, read_event :bool) returns (data_out :int; Q_EMPTY, Q_FULL :bool);
let

    (data_out, Q_EMPTY, Q_FULL) = FIFO(data_in,write_event,read_event);

-- Assertions.
--1. If write_event is always enabled and read_event is absent then Queue becomes Full. 
    check Q_FULL => Sofar(write_event and not read_event);
--2. If read_event is always enabled and write_event is absent then Queue becomes Empty. 
    check Q_EMPTY => Sofar(not write_event and read_event);
--3. Queue is never both empty and full at the same time.
    check not(Q_EMPTY = Q_FULL);
--4. If Queue is not Full and both write_event and read_event are enabled at same time then queue never becomes 
-- Full.
    
--5. If Queue is not Full and both write_event and read_event are enabled at same time then queue never becomes 
-- Full.

--6. If 
tel

node Sofar( i : bool ) returns ( o : bool );
let
 o = i -> (i and (pre o));
tel
